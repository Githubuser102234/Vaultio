<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vaultio - Secure Base64 Storage</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .vault-card {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        .btn-primary {
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-list-container {
            max-height: 400px;
        }
        .file-list-container::-webkit-scrollbar {
            width: 6px;
        }
        .file-list-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
        .file-preview-thumbnail {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Header Navigation -->
    <header class="bg-indigo-700 text-white shadow-lg p-4 flex justify-between items-center sticky top-0 z-10">
        <div class="text-2xl font-bold tracking-wider">
            <svg class="inline-block w-6 h-6 mr-2 -mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z"></path></svg>
            Vaultio
        </div>
        <button id="signOutButton" class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded-lg text-sm font-semibold transition hidden" onclick="handleSignOut()">
            Sign Out
        </button>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow p-4 md:p-8">

        <!-- Message/Error Box -->
        <div id="messageBox" class="hidden fixed top-20 left-1/2 transform -translate-x-1/2 w-full max-w-sm p-3 rounded-xl text-center z-50 transition-opacity duration-300 vault-card" role="alert">
            <!-- Message content goes here -->
        </div>

        <!-- Auth View -->
        <div id="authView" class="flex flex-col items-center justify-center min-h-[70vh]">
            <div class="vault-card p-8 w-full max-w-md rounded-2xl">
                <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">Welcome to Vaultio</h2>
                <form id="authForm" class="space-y-4">
                    <input type="email" id="email" placeholder="Email" required class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <input type="password" id="password" placeholder="Password" required class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <button type="submit" id="authSubmitButton" class="w-full btn-primary bg-indigo-600 text-white p-3 rounded-lg font-semibold hover:bg-indigo-700 flex items-center justify-center">
                        <span id="authText">Sign In</span>
                        <div id="authSpinner" class="spinner ml-2 hidden"></div>
                    </button>
                </form>
                <div class="text-center mt-4">
                    <button id="toggleAuthMode" class="text-sm text-indigo-600 hover:text-indigo-800 transition">
                        Need an account? Sign Up
                    </button>
                </div>
                <div class="flex items-center my-6">
                    <div class="flex-grow border-t border-gray-300"></div>
                    <span class="flex-shrink mx-4 text-gray-500 text-sm">OR</span>
                    <div class="flex-grow border-t border-gray-300"></div>
                </div>
                <button onclick="signInWithGoogle()" class="w-full btn-primary bg-white border border-gray-300 text-gray-700 p-3 rounded-lg font-semibold hover:bg-gray-50 flex items-center justify-center">
                    <img src="https://img.icons8.com/color/24/000000/google-logo.png" alt="Google logo" class="w-5 h-5 mr-3"/>
                    Sign In with Google
                </button>
            </div>
        </div>

        <!-- File Manager View (Home/Folder View) -->
        <div id="fileManagerView" class="hidden max-w-4xl mx-auto">

            <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800 mb-2 md:mb-0">File Manager</h1>
                <div class="flex space-x-2 w-full md:w-auto">
                    <button onclick="showCreateFolderModal()" class="bg-indigo-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-600 transition">
                        New Folder
                    </button>
                </div>
            </div>

            <!-- Breadcrumbs -->
            <nav id="breadcrumbs" class="text-sm text-gray-600 mb-4 flex items-center space-x-2">
                <!-- Breadcrumbs rendered here -->
            </nav>

            <!-- File Upload Section -->
            <div class="vault-card p-6 rounded-2xl mb-8">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Upload to: <span id="currentPathDisplay" class="font-mono text-indigo-600 text-base">/</span></h2>
                <input type="file" id="fileInput" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">

                <button id="uploadButton" onclick="handleFileUpload()" class="mt-4 btn-primary bg-green-500 text-white p-3 rounded-lg font-semibold hover:bg-green-600 w-full flex items-center justify-center" disabled>
                    <span id="uploadText">Upload File</span>
                    <div id="uploadSpinner" class="spinner ml-2 hidden"></div>
                </button>

                <div id="uploadProgress" class="mt-3 h-2 bg-gray-200 rounded-full hidden">
                    <div id="progressBar" class="h-2 bg-green-500 rounded-full transition-all duration-300" style="width: 0%;"></div>
                </div>
            </div>

            <!-- File/Folder List Section -->
            <div class="vault-card p-6 rounded-2xl">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Contents</h2>

                <div class="file-list-container overflow-y-auto">
                    <ul id="fileList" class="divide-y divide-gray-200">
                        <!-- Contents rendered here -->
                    </ul>
                </div>
            </div>
        </div>

        <!-- File Viewer View -->
        <div id="fileViewerView" class="hidden max-w-4xl mx-auto vault-card p-6 rounded-2xl">
            <button onclick="navigate(currentPath)" class="text-indigo-600 hover:text-indigo-800 mb-4 flex items-center transition">
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                Back to Folder
            </button>
            <h1 id="viewerTitle" class="text-3xl font-bold text-gray-800 mb-4"></h1>
            <p id="viewerMetadata" class="text-sm text-gray-500 mb-6"></p>

            <div id="viewerContent" class="w-full bg-gray-100 p-4 rounded-lg overflow-auto max-h-[70vh] flex justify-center items-center">
                <!-- File content (image/video/text/editor) rendered here -->
            </div>
            
            <div id="editorActions" class="flex justify-end mt-4 hidden">
                <button id="saveButton" class="btn-primary bg-indigo-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-700 flex items-center justify-center">
                    <span id="saveText">Save Changes</span>
                    <div id="saveSpinner" class="spinner ml-2 hidden"></div>
                </button>
            </div>
            
            <div id="viewerLoading" class="hidden text-center p-8 text-indigo-600">
                <div class="mx-auto spinner"></div>
                <p class="mt-3">Loading all file chunks...</p>
            </div>
        </div>

        <!-- Create Folder Modal -->
        <div id="folderModal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
            <div class="bg-white p-6 rounded-xl w-full max-w-sm vault-card">
                <h3 class="text-xl font-semibold mb-4">Create New Folder</h3>
                <input type="text" id="folderNameInput" placeholder="Folder Name (e.g., Photos)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 mb-4">
                <div class="flex justify-end space-x-3">
                    <button onclick="hideCreateFolderModal()" class="bg-gray-300 text-gray-800 py-2 px-4 rounded-lg hover:bg-gray-400 transition">Cancel</button>
                    <button onclick="createFolder()" class="bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition">Create</button>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signInWithPopup,
            GoogleAuthProvider,
            onAuthStateChanged,
            signOut
        } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import {
            getFirestore,
            collection,
            doc,
            setDoc,
            getDocs,
            deleteDoc,
            query,
            serverTimestamp,
            getDoc, // Added getDoc for single file metadata
        } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

        // --- Configuration and Initialization ---

        // NOTE: Keeping the previous hardcoded config for your GitHub Pages environment.
        const firebaseConfig = {
            apiKey: "AIzaSyAY_xxThXsNlAf_HGQFXBk1dGa6rtexbYM",
            authDomain: "vaultio-8bbdb.firebaseapp.com",
            projectId: "vaultio-8bbdb",
            storageBucket: "vaultio-8bbdb.firebasestorage.app",
            messagingSenderId: "685851019361",
            appId: "1:685851019361:web:4c074c4eea95ac9bef8220",
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Constants and Global State ---

        const CHUNK_SIZE_CHARS = 500 * 1024;
        let isSignUpMode = false;
        let currentUserId = null;
        let currentPath = '/'; // Root folder path

        // --- Utility Functions ---

        const showMessage = (message, type = 'info') => {
            const box = document.getElementById('messageBox');
            const colorClass = type === 'error' ? 'bg-red-500 text-white' :
                                 type === 'success' ? 'bg-green-500 text-white' :
                                 'bg-blue-500 text-white';

            if (type === 'error') {
                console.error("UI Error Message:", message);
            }

            box.className = `fixed top-20 left-1/2 transform -translate-x-1/2 w-full max-w-sm p-4 rounded-xl text-center z-50 transition-opacity duration-300 vault-card opacity-0 ${colorClass}`;
            box.textContent = message;

            box.classList.remove('hidden');
            setTimeout(() => { box.classList.remove('opacity-0'); box.classList.add('opacity-100'); }, 10);
            setTimeout(() => { box.classList.remove('opacity-100'); box.classList.add('opacity-0'); }, 3000);
            setTimeout(() => { box.classList.add('hidden'); }, 3500);
        };

        const toggleLoading = (buttonId, spinnerId, textId, isLoading) => {
            const button = document.getElementById(buttonId);
            const spinner = document.getElementById(spinnerId);
            const text = document.getElementById(textId);

            button.disabled = isLoading;
            if (isLoading) {
                spinner.classList.remove('hidden');
                text.classList.add('hidden');
                button.classList.add('opacity-75');
            } else {
                spinner.classList.add('hidden');
                text.classList.remove('hidden');
                button.classList.remove('opacity-75');
            }
        };

        /**
         * Converts Base64 data string back into a Blob object.
         */
        const base64ToBlob = (base64Data, fileType) => {
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: fileType });
        };

        /**
         * Converts a string to Base64 (used for saving edited text files).
         */
        const stringToBase64 = (str) => {
            const binaryString = String.fromCharCode.apply(null, new Uint8Array(new TextEncoder().encode(str)));
            return btoa(binaryString);
        };

        // --- Navigation and Routing ---

        const navigate = (path, replace = false) => {
            const search = `?nav=${encodeURIComponent(path)}`;
            if (replace) {
                window.history.replaceState(null, '', search);
            } else {
                window.history.pushState(null, '', search);
            }
            handleRoute();
        };
        window.navigate = navigate;

        const getRouteParams = () => {
            const params = new URLSearchParams(window.location.search);
            const nav = params.get('nav') || '/';
            const parts = nav.split('/');

            if (parts[1] === 'file' && parts.length === 3 && parts[2]) {
                return { name: 'fileViewer', fileId: parts[2] };
            }
            // Ensure path ends with a slash and starts with one, unless it's just '/'
            const normalizedPath = nav === '/' ? '/' : (nav.startsWith('/') ? nav : '/' + nav).replace(/\/\/+/g, '/');
            return { name: 'fileManager', path: normalizedPath.endsWith('/') ? normalizedPath : normalizedPath + '/' };
        };

        const handleRoute = () => {
            if (!currentUserId) return; // Wait for auth

            const route = getRouteParams();
            const managerView = document.getElementById('fileManagerView');
            const viewerView = document.getElementById('fileViewerView');

            if (route.name === 'fileManager') {
                managerView.classList.remove('hidden');
                viewerView.classList.add('hidden');
                // Ensure currentPath is a valid, slash-ending path
                currentPath = route.path; 
                document.getElementById('currentPathDisplay').textContent = currentPath;
                renderBreadcrumbs();
                fetchFiles();
            } else if (route.name === 'fileViewer' && route.fileId) {
                managerView.classList.add('hidden');
                viewerView.classList.remove('hidden');
                renderFileViewer(route.fileId);
            }
        };
        window.addEventListener('popstate', handleRoute);

        const renderBreadcrumbs = () => {
            const breadcrumbsEl = document.getElementById('breadcrumbs');
            breadcrumbsEl.innerHTML = '';
            
            // Normalize currentPath for segment splitting
            const pathSegments = currentPath.split('/').filter(s => s); 

            // Root Link
            const rootLink = document.createElement('a');
            rootLink.className = 'text-indigo-600 hover:text-indigo-800 cursor-pointer';
            rootLink.textContent = 'Vault';
            rootLink.onclick = () => navigate('/');
            breadcrumbsEl.appendChild(rootLink);
            
            let cumulativePath = '/';

            pathSegments.forEach((segment, index) => {
                breadcrumbsEl.appendChild(document.createTextNode(' / '));

                cumulativePath = (cumulativePath === '/') ? `/${segment}/` : `${cumulativePath}${segment}/`;

                if (index < pathSegments.length - 1) {
                    // Intermediate folder
                    const segmentLink = document.createElement('a');
                    segmentLink.className = 'text-indigo-600 hover:text-indigo-800 cursor-pointer';
                    segmentLink.textContent = segment;
                    const pathCopy = cumulativePath;
                    segmentLink.onclick = () => navigate(pathCopy);
                    breadcrumbsEl.appendChild(segmentLink);
                } else {
                    // Current folder (just display text)
                    const currentSpan = document.createElement('span');
                    currentSpan.className = 'font-semibold text-gray-800';
                    currentSpan.textContent = segment;
                    breadcrumbsEl.appendChild(currentSpan);
                }
            });
        };

        // --- Authentication Logic (omitted for brevity) ---

        document.getElementById('toggleAuthMode').addEventListener('click', () => {
            isSignUpMode = !isSignUpMode;
            document.getElementById('authText').textContent = isSignUpMode ? 'Sign Up' : 'Sign In';
            document.getElementById('toggleAuthMode').textContent = isSignUpMode ? 'Already have an account? Sign In' : 'Need an account? Sign Up';
        });

        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const buttonId = 'authSubmitButton';
            const spinnerId = 'authSpinner';
            const textId = 'authText';
            toggleLoading(buttonId, spinnerId, textId, true);
            try {
                if (isSignUpMode) {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showMessage('Account created successfully!', 'success');
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage('Signed in successfully!', 'success');
                }
            } catch (error) {
                console.error("Auth Error:", error);
                showMessage(error.message.replace('Firebase: ', ''), 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
            }
        });

        const signInWithGoogle = async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Auth Error:", error);
                showMessage(error.message.replace('Firebase: ', ''), 'error');
            }
        };
        window.signInWithGoogle = signInWithGoogle;

        const handleSignOut = async () => {
            try {
                await signOut(auth);
                showMessage('Signed out.', 'info');
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessage('Could not sign out.', 'error');
            }
        };
        window.handleSignOut = handleSignOut;

        // --- Firestore Paths ---

        const getFileMetadataCollection = (userId) => {
            return collection(db, `users/${userId}/files`);
        };

        const getFileChunksCollection = (userId, fileId) => {
            return collection(db, `users/${userId}/files/${fileId}/chunks`);
        };

        // --- File I/O Logic (Chunking & Dechunking) ---

        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        /**
         * Saves Base64 data in chunks to Firestore, updating existing file or creating new metadata.
         */
        const saveFileChunks = async (base64Data, fileName, fileType, currentPath, fileId = null, onProgress = () => {}) => {
            if (!currentUserId) throw new Error("User not authenticated.");

            const chunks = [];
            for (let i = 0; i < base64Data.length; i += CHUNK_SIZE_CHARS) {
                chunks.push(base64Data.substring(i, i + CHUNK_SIZE_CHARS));
            }
            const totalChunks = chunks.length;
            const fileSize = base64Data.length;
            const metadataCollection = getFileMetadataCollection(currentUserId);

            // 1. Determine or Create Metadata Document
            const metadataRef = fileId ? doc(metadataCollection, fileId) : doc(metadataCollection);
            
            await setDoc(metadataRef, {
                fileName,
                fileType,
                fileSize,
                totalChunks,
                path: currentPath, 
                // Only update uploadedAt if it's a new file, otherwise use serverTimestamp as update time
                uploadedAt: fileId ? getDoc(metadataRef).then(d => d.data().uploadedAt) : serverTimestamp(),
                updatedAt: serverTimestamp(),
            }, { merge: true });

            // 2. Clear old chunks (if updating) and Save new Chunks
            const chunksCollection = getFileChunksCollection(currentUserId, metadataRef.id);
            
            if (fileId) {
                // For updates, aggressively delete existing chunks first
                const oldChunks = await getDocs(query(chunksCollection));
                for (const oldDoc of oldChunks.docs) {
                    await deleteDoc(oldDoc.ref);
                }
            }

            for (let i = 0; i < totalChunks; i++) {
                const chunkData = chunks[i];
                await setDoc(doc(chunksCollection, String(i)), {
                    chunkIndex: i,
                    data: chunkData
                });
                onProgress(((i + 1) / totalChunks) * 100);
            }

            return metadataRef.id;
        };
        
        /**
         * Loads and reconstructs a file from Firestore chunks, returning the full Base64 string.
         */
        const loadFileChunksBase64 = async (fileId, totalChunks) => {
            if (!currentUserId) throw new Error("User not authenticated.");

            const chunksCollection = getFileChunksCollection(currentUserId, fileId);
            const q = query(chunksCollection);
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                throw new Error("No chunks found for this file.");
            }

            const sortedChunks = querySnapshot.docs.map(doc => doc.data())
                .sort((a, b) => a.chunkIndex - b.chunkIndex);

            if (sortedChunks.length < totalChunks) {
                 console.warn(`File ${fileId} expected ${totalChunks} chunks, found ${sortedChunks.length}. Attempting reconstruction.`);
            }

            const allChunks = sortedChunks.map(chunk => chunk.data).join('');
            return allChunks;
        };


        // --- UI Interactions ---

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const uploadButton = document.getElementById('uploadButton');
            uploadButton.disabled = e.target.files.length === 0;
        });

        const showCreateFolderModal = () => {
            document.getElementById('folderModal').classList.remove('hidden');
            document.getElementById('folderNameInput').focus();
        };
        window.showCreateFolderModal = showCreateFolderModal;

        const hideCreateFolderModal = () => {
            document.getElementById('folderModal').classList.add('hidden');
            document.getElementById('folderNameInput').value = '';
        };
        window.hideCreateFolderModal = hideCreateFolderModal;

        const createFolder = async () => {
            const folderName = document.getElementById('folderNameInput').value.trim();
            hideCreateFolderModal();

            if (!folderName) {
                showMessage('Folder name cannot be empty.', 'error');
                return;
            }

            // Clean up name to be path-safe
            const cleanName = folderName.replace(/[/\\]/g, '').trim();
            
            // Check if a synthetic folder already exists to prevent duplicates in the UI list
            const metadataCollection = getFileMetadataCollection(currentUserId);
            const existingQuery = query(metadataCollection, 
                where('path', '==', currentPath), 
                where('isFolder', '==', true),
                where('fileName', '==', cleanName)
            );
            const existingDocs = await getDocs(existingQuery);

            if (!existingDocs.empty) {
                 showMessage(`Folder '${cleanName}' already exists.`, 'info');
                 navigate(currentPath + cleanName + '/');
                 return;
            }

            try {
                // Add a placeholder document that signifies the folder's existence.
                 await setDoc(doc(metadataCollection), {
                    fileName: cleanName,
                    fileType: 'folder/placeholder',
                    fileSize: 0,
                    totalChunks: 0,
                    path: currentPath,
                    isFolder: true,
                    uploadedAt: serverTimestamp(),
                });
                showMessage(`Folder '${cleanName}' created!`, 'success');
                // Navigate into the new folder for immediate use
                navigate(currentPath + cleanName + '/'); 
            } catch (error) {
                showMessage(`Failed to create folder: ${error.message}`, 'error');
            }
        };
        window.createFolder = createFolder;


        const handleFileUpload = async () => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                showMessage('Please select a file first.', 'error');
                return;
            }

            const buttonId = 'uploadButton';
            const spinnerId = 'uploadSpinner';
            const textId = 'uploadText';
            const progressBarEl = document.getElementById('progressBar');
            const progressContainer = document.getElementById('uploadProgress');

            toggleLoading(buttonId, spinnerId, textId, true);
            progressBarEl.style.width = '0%';
            progressContainer.classList.remove('hidden');

            try {
                const base64Data = await fileToBase64(file);

                await saveFileChunks(
                    base64Data,
                    file.name,
                    file.type || 'application/octet-stream',
                    currentPath, // Pass the current folder path
                    null, // fileId is null for new upload
                    (progress) => {
                        progressBarEl.style.width = `${progress}%`;
                    }
                );

                showMessage('File uploaded and chunked successfully!', 'success');
                fileInput.value = null;
                uploadButton.disabled = true;
                fetchFiles();

            } catch (error) {
                console.error("Upload Error:", error);
                showMessage(`Upload failed: ${error.message}`, 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
                setTimeout(() => progressContainer.classList.add('hidden'), 500);
            }
        };
        window.handleFileUpload = handleFileUpload;

        /**
         * Renders the list of files and folders in the UI.
         */
        const renderFiles = (files) => {
            const fileListEl = document.getElementById('fileList');
            fileListEl.innerHTML = '';
            
            // Separate files and folders for sorting and display
            const filesToDisplay = files.filter(f => !f.isFolder);
            const folderFiles = files.filter(f => f.isFolder);

            // 1. Identify and normalize folders
            const folders = new Map();
            
            // Add explicit placeholder folders
            folderFiles.forEach(file => {
                 if (file.path === currentPath) {
                    folders.set(file.fileName, file.fileName);
                 }
            });

            // Add synthetic folders (derived from file paths)
            filesToDisplay.forEach(file => {
                 // Check if the file is in an immediate subfolder
                const remainingPath = file.path.substring(currentPath.length);
                const segments = remainingPath.split('/').filter(s => s); // ['Folder', 'Subfolder', 'file.txt']
                
                if (segments.length >= 1) {
                    // This is the immediate subfolder name
                    const folderName = segments[0];
                    folders.set(folderName, folderName);
                }
            });
            
            const folderNames = Array.from(folders.keys()).sort();

            if (filesToDisplay.length === 0 && folderNames.length === 0) {
                const placeholderLi = document.createElement('li');
                placeholderLi.className = 'p-4 text-gray-500 text-center';
                placeholderLi.textContent = 'This folder is empty.';
                fileListEl.appendChild(placeholderLi);
                return;
            }

            // 2. Render Folders
            folderNames.forEach(folderName => {
                const folderPath = currentPath + folderName + '/';
                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center hover:bg-gray-50 transition rounded-lg cursor-pointer';
                li.onclick = () => navigate(folderPath);
                li.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <svg class="w-6 h-6 text-yellow-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v2a2 2 0 00-2-2h-8l-2-2H4a2 2 0 00-2 2v6a2 2 0 002 2h12a2 2 0 002-2v-2a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path></svg>
                        <p class="font-semibold text-gray-800">${folderName}</p>
                    </div>
                    <div class="text-sm text-gray-500">
                         Folder
                    </div>
                `;
                fileListEl.appendChild(li);
            });


            // 3. Render Files (Filter files to only show those directly in the current path)
            const filesDirectlyInPath = filesToDisplay.filter(file => file.path === currentPath);
            
            filesDirectlyInPath.sort((a, b) => {
                const timeA = a.uploadedAt?.toDate?.()?.getTime() || 0;
                const timeB = b.uploadedAt?.toDate?.()?.getTime() || 0;
                return timeB - timeA; // Newest first
            });
            
            filesDirectlyInPath.forEach(file => {
                const uploadedDate = file.uploadedAt?.toDate?.()?.toLocaleDateString() || 'Pending...';
                const fileName = file.fileName || 'Untitled File';
                const fileSize = file.fileSize || 0;
                const totalChunks = file.totalChunks || 0;
                const fileSizeMB = (fileSize / 1024 / 1024).toFixed(2);
                const fileType = file.fileType || '';

                let iconHtml = '';
                if (fileType.startsWith('image/')) {
                    // Image with Base64 thumbnail for preview
                    const firstChunk = file.firstChunk || '';
                    iconHtml = `
                        <img src="data:${fileType};base64,${firstChunk}" 
                            class="file-preview-thumbnail object-cover" 
                            alt="Preview" 
                            onerror="this.src='https://placehold.co/48x48/CCCCCC/FFFFFF?text=IMG'">
                    `;
                } else if (fileType.startsWith('video/')) {
                    iconHtml = `<svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14m-5-4v4"></path></svg>`;
                } else if (fileType.includes('pdf')) {
                     iconHtml = `<svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>`;
                } else {
                    iconHtml = `<svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>`;
                }

                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center hover:bg-gray-50 transition rounded-lg cursor-pointer';
                li.onclick = () => navigate(`/file/${file.id}`); // View file on click
                li.innerHTML = `
                    <div class="flex items-center space-x-3 w-3/5">
                        <div class="flex-shrink-0">
                            ${iconHtml}
                        </div>
                        <p class="font-medium text-gray-800 truncate">${fileName}</p>
                    </div>
                    <div class="flex items-center space-x-4">
                        <p class="text-sm text-gray-500 hidden sm:block">${fileSizeMB} MB</p>
                        <button class="delete-btn bg-red-500 text-white p-2 rounded-full hover:bg-red-600 transition flex-shrink-0" data-file-id="${file.id}" title="Delete File" onclick="event.stopPropagation(); handleFileDelete('${file.id}');">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </div>
                `;
                fileListEl.appendChild(li);
            });
        };

        const isEditable = (fileType) => {
            return fileType.startsWith('text/') || 
                   fileType.includes('json') || 
                   fileType.includes('xml') ||
                   fileType.includes('javascript') ||
                   fileType.includes('css') ||
                   fileType.includes('html');
        };

        const renderFileViewer = async (fileId) => {
            const viewerTitleEl = document.getElementById('viewerTitle');
            const viewerMetadataEl = document.getElementById('viewerMetadata');
            const viewerContentEl = document.getElementById('viewerContent');
            const viewerLoadingEl = document.getElementById('viewerLoading');
            const editorActionsEl = document.getElementById('editorActions');

            viewerContentEl.innerHTML = '';
            editorActionsEl.classList.add('hidden');
            viewerTitleEl.textContent = 'Loading File...';
            viewerMetadataEl.textContent = '';
            viewerLoadingEl.classList.remove('hidden');

            try {
                // 1. Fetch metadata
                const metadataDoc = await getDoc(doc(getFileMetadataCollection(currentUserId), fileId));
                if (!metadataDoc.exists()) {
                    throw new Error("File not found.");
                }
                const file = { id: metadataDoc.id, ...metadataDoc.data() };
                const totalChunks = file.totalChunks || 0;
                const fileName = file.fileName || 'Unknown File';
                const fileSizeMB = ((file.fileSize || 0) / 1024 / 1024).toFixed(2);
                const fileType = file.fileType || 'application/octet-stream';
                
                viewerTitleEl.textContent = fileName;
                viewerMetadataEl.textContent = `Type: ${fileType} | Size: ${fileSizeMB} MB | Chunks: ${totalChunks}`;
                
                // 2. Load all chunks
                const fullBase64 = await loadFileChunksBase64(fileId, totalChunks);
                const blob = base64ToBlob(fullBase64, fileType);
                const objectUrl = URL.createObjectURL(blob);

                // 3. Render content based on MIME type
                if (fileType.startsWith('image/')) {
                    viewerContentEl.innerHTML = `<img src="${objectUrl}" alt="${fileName}" class="max-w-full max-h-full rounded-lg shadow-xl" onerror="this.outerHTML='<p class=\\'text-red-500\\'>Error displaying image.</p>'">`;
                } else if (fileType.startsWith('video/')) {
                    viewerContentEl.innerHTML = `<video src="${objectUrl}" controls class="max-w-full max-h-full rounded-lg shadow-xl"></video>`;
                } else if (isEditable(fileType)) {
                    // For editable text-based files, render an editor
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        viewerContentEl.innerHTML = `
                            <textarea id="fileEditor" class="w-full h-[60vh] p-4 text-sm bg-gray-50 border border-gray-200 rounded-lg resize-none font-mono">${content}</textarea>
                        `;
                        editorActionsEl.classList.remove('hidden');
                        
                        // Attach save listener
                        document.getElementById('saveButton').onclick = () => saveFileContent(fileId, fileName, fileType);
                    };
                    reader.readAsText(blob);
                } else {
                    // Fallback: offer download button
                    viewerContentEl.innerHTML = `
                        <div class="text-center p-8">
                            <p class="text-lg text-gray-700 mb-4">No in-browser preview available for ${fileType}.</p>
                            <button onclick="downloadBlob('${objectUrl}', '${fileName}')" class="bg-indigo-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-700 transition">
                                Download File
                            </button>
                        </div>
                    `;
                }
                
                // Cleanup Object URL after rendering (it's safe here because content is loaded)
                URL.revokeObjectURL(objectUrl); 

            } catch (error) {
                console.error("Viewer Error:", error);
                viewerContentEl.innerHTML = `<p class="text-red-500">Failed to load file: ${error.message}</p>`;
                showMessage(`Failed to load file: ${error.message}`, 'error');
            } finally {
                viewerLoadingEl.classList.add('hidden');
            }
        };
        window.renderFileViewer = renderFileViewer; // Make global for button handlers

        const saveFileContent = async (fileId, fileName, fileType) => {
            const editorEl = document.getElementById('fileEditor');
            const newContent = editorEl.value;
            const newBase64Data = stringToBase64(newContent);
            
            const buttonId = 'saveButton';
            const spinnerId = 'saveSpinner';
            const textId = 'saveText';

            toggleLoading(buttonId, spinnerId, textId, true);

            try {
                // Get the current path from the file's metadata for re-saving
                const metadataDoc = await getDoc(doc(getFileMetadataCollection(currentUserId), fileId));
                const currentPath = metadataDoc.data().path || '/';

                await saveFileChunks(
                    newBase64Data, 
                    fileName, 
                    fileType, 
                    currentPath, 
                    fileId // Pass fileId to update existing document
                );
                
                showMessage(`File '${fileName}' saved successfully!`, 'success');
                // Re-render the viewer to show updated metadata (size, chunks, etc.)
                renderFileViewer(fileId); 

            } catch (error) {
                console.error("Save Error:", error);
                showMessage(`Failed to save file: ${error.message}`, 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
            }
        };

        const downloadBlob = (objectUrl, fileName) => {
            const a = document.createElement('a');
            a.href = objectUrl;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        window.downloadBlob = downloadBlob;

        const handleFileDelete = async (fileId) => {
            if (!window.confirm("Are you sure you want to delete this file and all its chunks? This action is permanent.")) {
                return;
            }

            try {
                // 1. Delete all chunks
                const chunksCollection = getFileChunksCollection(currentUserId, fileId);
                const q = query(chunksCollection);
                const chunkDocs = await getDocs(q);

                for (const docSnapshot of chunkDocs.docs) {
                    await deleteDoc(docSnapshot.ref);
                }

                // 2. Delete the metadata document
                const metadataRef = doc(getFileMetadataCollection(currentUserId), fileId);
                await deleteDoc(metadataRef);

                showMessage('File and all chunks deleted successfully!', 'success');
                
                // If we deleted the file we are currently viewing, navigate home.
                const route = getRouteParams();
                if (route.name === 'fileViewer' && route.fileId === fileId) {
                    navigate(currentPath);
                } else {
                    fetchFiles();
                }

            } catch (error) {
                console.error("Delete Error:", error);
                showMessage(`Failed to delete file: ${error.message}`, 'error');
            }
        };
        window.handleFileDelete = handleFileDelete;

        const fetchFiles = async () => {
            if (!currentUserId) return;

            try {
                const metadataCollection = getFileMetadataCollection(currentUserId);
                // Fetch ALL documents to enable client-side folder/subfolder logic
                const q = query(metadataCollection);
                const querySnapshot = await getDocs(q);

                const allFiles = querySnapshot.docs.map(doc => {
                    const data = doc.data();
                    // CRITICAL FIX: Ensure 'path' exists for old documents
                    if (data.path === undefined || data.path === null) {
                        data.path = '/'; 
                    }
                    // Normalize path to always end with a slash for consistent comparison
                    if (data.path !== '/' && !data.path.endsWith('/')) {
                        data.path += '/';
                    }
                    
                    // Simple hack to include the first chunk for image previews in the list
                    // WARNING: This is a fast but non-scalable way to get preview data
                    if (data.fileType && data.fileType.startsWith('image/') && data.totalChunks > 0 && data.firstChunk === undefined) {
                        // Attempt to load the first chunk for preview thumbnail
                         getDoc(doc(getFileChunksCollection(currentUserId, doc.id), '0')).then(chunkDoc => {
                            if (chunkDoc.exists()) {
                                data.firstChunk = chunkDoc.data().data;
                                // Re-render the file list after the preview data arrives
                                fetchFiles(); 
                            }
                         }).catch(e => console.warn("Failed to fetch first chunk for preview:", e));
                    }
                    
                    return {
                        id: doc.id,
                        ...data
                    };
                });

                // Filter logic is now simpler and safer because file.path is guaranteed to exist and be normalized.
                const filesInCurrentPath = allFiles.filter(file => {
                    // 1. Files directly in the current path (files or placeholder folders)
                    if (file.path === currentPath) {
                        return true;
                    }

                    // 2. Files in immediate subfolders (synthetic folders)
                    if (file.path.startsWith(currentPath) && file.path.length > currentPath.length) {
                        const remainingPath = file.path.substring(currentPath.length);
                        // Is this an immediate subfolder? Check if there are no more slashes in the remainder
                        if (remainingPath.indexOf('/') === remainingPath.length - 1) {
                            return true; // Yes, this file proves a folder exists at this path
                        }
                    }
                    
                    return false;
                });
                
                renderFiles(filesInCurrentPath);

            } catch (error) {
                console.error("Fetch Files Error:", error);
                showMessage(`Could not load files. Error: ${error.message || 'Unknown error'}. Please check console.`, 'error');
            }
        };


        // --- Auth State Change Listener ---

        onAuthStateChanged(auth, (user) => {
            const authView = document.getElementById('authView');
            const signOutButton = document.getElementById('signOutButton');
            const fileManagerView = document.getElementById('fileManagerView');

            if (user) {
                currentUserId = user.uid;
                authView.classList.add('hidden');
                signOutButton.classList.remove('hidden');
                // Call handleRoute after successful sign-in
                handleRoute();
            } else {
                currentUserId = null;
                authView.classList.remove('hidden');
                // Hide file views on sign-out
                fileManagerView.classList.add('hidden');
                document.getElementById('fileViewerView').classList.add('hidden');
                signOutButton.classList.add('hidden');
            }
        });
        
        // Ensure initial route is handled on page load
        if (document.readyState === 'complete') {
            handleRoute();
        } else {
            window.addEventListener('load', handleRoute);
        }

    </script>
</body>
</html>

