<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vaultio - Secure Base64 Storage</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .vault-card {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            background-color: white;
        }
        .btn-primary {
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary:hover {
            transform: translateY(-1px);
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #ffffff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .file-list-container {
            max-height: 400px;
        }
        .file-list-container::-webkit-scrollbar {
            width: 6px;
        }
        .file-list-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
        .file-preview-thumbnail {
            width: 48px;
            height: 48px;
            object-fit: cover;
            border-radius: 6px;
        }
        /* Custom modal styles */
        .modal {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Header Navigation -->
    <header class="bg-indigo-700 text-white shadow-lg p-4 flex justify-between items-center sticky top-0 z-10">
        <div class="text-2xl font-bold tracking-wider">
            <svg class="inline-block w-6 h-6 mr-2 -mt-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 14v3m4-3v3m4-3v3M3 21h18M3 10h18M3 7l9-4 9 4M4 10h16v11H4V10z"></path></svg>
            Vaultio
        </div>
        <button id="signOutButton" class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded-lg text-sm font-semibold transition hidden" onclick="handleSignOut()">
            Sign Out
        </button>
    </header>

    <!-- Main Content Area -->
    <main class="flex-grow p-4 md:p-8">

        <!-- Message/Error Box -->
        <div id="messageBox" class="hidden fixed top-20 left-1/2 transform -translate-x-1/2 w-full max-w-sm p-3 rounded-xl text-center z-50 transition-opacity duration-300 vault-card" role="alert">
            <!-- Message content goes here -->
        </div>

        <!-- Auth View -->
        <div id="authView" class="flex flex-col items-center justify-center min-h-[70vh]">
            <div class="vault-card p-8 w-full max-w-md rounded-2xl">
                <h2 class="text-3xl font-bold text-gray-800 mb-6 text-center">Welcome to Vaultio</h2>
                <form id="authForm" class="space-y-4">
                    <input type="email" id="email" placeholder="Email" required class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <input type="password" id="password" placeholder="Password" required class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                    <button type="submit" id="authSubmitButton" class="w-full btn-primary bg-indigo-600 text-white p-3 rounded-lg font-semibold hover:bg-indigo-700 flex items-center justify-center">
                        <span id="authText">Sign In</span>
                        <div id="authSpinner" class="spinner ml-2 hidden"></div>
                    </button>
                </form>
                <div class="text-center mt-4">
                    <button id="toggleAuthMode" class="text-sm text-indigo-600 hover:text-indigo-800 transition">
                        Need an account? Sign Up
                    </button>
                </div>
                <div class="flex items-center my-6">
                    <div class="flex-grow border-t border-gray-300"></div>
                    <span class="flex-shrink mx-4 text-gray-500 text-sm">OR</span>
                    <div class="flex-grow border-t border-gray-300"></div>
                </div>
                <button onclick="signInWithGoogle()" class="w-full btn-primary bg-white border border-gray-300 text-gray-700 p-3 rounded-lg font-semibold hover:bg-gray-50 flex items-center justify-center">
                    <img src="https://img.icons8.com/color/24/000000/google-logo.png" alt="Google logo" class="w-5 h-5 mr-3"/>
                    Sign In with Google
                </button>
            </div>
        </div>

        <!-- File Manager View (Home/Folder View) -->
        <div id="fileManagerView" class="hidden max-w-4xl mx-auto">

            <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6">
                <h1 class="text-3xl font-bold text-gray-800 mb-2 md:mb-0">File Manager</h1>
                <div class="flex space-x-2 w-full md:w-auto">
                    <button onclick="showCreateFolderModal()" class="bg-indigo-500 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-600 transition">
                        New Folder
                    </button>
                </div>
            </div>

            <!-- Breadcrumbs -->
            <nav id="breadcrumbs" class="text-sm text-gray-600 mb-4 flex items-center space-x-2">
                <!-- Breadcrumbs rendered here -->
            </nav>

            <!-- File Upload Section -->
            <div class="vault-card p-6 rounded-2xl mb-8">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Upload to: <span id="currentPathDisplay" class="font-mono text-indigo-600 text-base">/</span></h2>
                <input type="file" id="fileInput" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">

                <button id="uploadButton" onclick="handleFileUpload()" class="mt-4 btn-primary bg-green-500 text-white p-3 rounded-lg font-semibold hover:bg-green-600 w-full flex items-center justify-center" disabled>
                    <span id="uploadText">Upload File</span>
                    <div id="uploadSpinner" class="spinner ml-2 hidden"></div>
                </button>

                <div id="uploadProgress" class="mt-3 h-2 bg-gray-200 rounded-full hidden">
                    <div id="progressBar" class="h-2 bg-green-500 rounded-full transition-all duration-300" style="width: 0%;"></div>
                </div>
            </div>

            <!-- File/Folder List Section -->
            <div class="vault-card p-6 rounded-2xl">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Contents</h2>

                <div class="file-list-container overflow-y-auto">
                    <ul id="fileList" class="divide-y divide-gray-200">
                        <!-- Contents rendered here -->
                    </ul>
                </div>
            </div>
        </div>

        <!-- File Viewer View -->
        <div id="fileViewerView" class="hidden max-w-4xl mx-auto vault-card p-6 rounded-2xl">
            <button id="backToFolderButton" class="text-indigo-600 hover:text-indigo-800 mb-4 flex items-center transition">
                <svg class="w-5 h-5 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                Back to Folder
            </button>
            <h1 id="viewerTitle" class="text-3xl font-bold text-gray-800 mb-4"></h1>
            <p id="viewerMetadata" class="text-sm text-gray-500 mb-6"></p>

            <div id="viewerContent" class="w-full bg-gray-100 p-4 rounded-lg overflow-auto max-h-[70vh] flex justify-center items-center">
                <!-- File content (image/video/text/editor) rendered here -->
            </div>
            
            <div id="editorActions" class="flex justify-end mt-4 hidden">
                <button id="saveButton" class="btn-primary bg-indigo-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-700 flex items-center justify-center">
                    <span id="saveText">Save Changes</span>
                    <div id="saveSpinner" class="spinner ml-2 hidden"></div>
                </button>
            </div>
            
            <div id="viewerLoading" class="hidden text-center p-8 text-indigo-600">
                <div class="mx-auto spinner"></div>
                <p class="mt-3">Loading all file chunks...</p>
            </div>
        </div>

        <!-- Create Folder Modal -->
        <div id="folderModal" class="modal hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
            <div class="bg-white p-6 rounded-xl w-full max-w-sm vault-card">
                <h3 class="text-xl font-semibold mb-4">Create New Folder</h3>
                <input type="text" id="folderNameInput" placeholder="Folder Name (e.g., Photos)" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 mb-4">
                <div class="flex justify-end space-x-3">
                    <button onclick="hideCreateFolderModal()" class="bg-gray-300 text-gray-800 py-2 px-4 rounded-lg hover:bg-gray-400 transition">Cancel</button>
                    <button onclick="createFolder()" class="bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition">Create</button>
                </div>
            </div>
        </div>
        
        <!-- Rename Folder Modal (Reusing structure from folderModal) -->
        <div id="renameModal" class="modal hidden fixed inset-0 bg-gray-900 bg-opacity-75 z-50 flex items-center justify-center">
            <div class="bg-white p-6 rounded-xl w-full max-w-sm vault-card">
                <h3 class="text-xl font-semibold mb-4">Rename Folder</h3>
                <input type="text" id="newFolderNameInput" placeholder="New Folder Name" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 mb-4">
                <div class="flex justify-end space-x-3">
                    <button onclick="hideRenameModal()" class="bg-gray-300 text-gray-800 py-2 px-4 rounded-lg hover:bg-gray-400 transition">Cancel</button>
                    <button id="renameExecuteButton" class="bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 transition">Rename</button>
                </div>
            </div>
        </div>
    </main>

    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signInWithPopup,
            GoogleAuthProvider,
            onAuthStateChanged,
            signOut
        } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
        import {
            getFirestore,
            collection,
            doc, // Firebase doc function
            setDoc,
            getDocs,
            deleteDoc,
            query,
            serverTimestamp,
            getDoc,
            where,
            updateDoc,
            writeBatch // Used for atomic batch updates (rename/delete)
        } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";

        // --- Configuration and Initialization ---

        // NOTE: Keeping the previous hardcoded config for your GitHub Pages environment.
        const firebaseConfig = {
            apiKey: "AIzaSyAY_xxThXsNlAf_HGQFXBk1dGa6rtexbYM",
            authDomain: "vaultio-8bbdb.firebaseapp.com",
            projectId: "vaultio-8bbdb",
            storageBucket: "vaultio-8bbdb.firebasestorage.app",
            messagingSenderId: "685851019361",
            appId: "1:685851019361:web:4c074c4eea95ac9bef8220",
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- Constants and Global State ---

        const CHUNK_SIZE_CHARS = 500 * 1024;
        let isSignUpMode = false;
        let currentUserId = null;
        let currentPath = '/'; // Root folder path

        // --- Utility Functions (showMessage, toggleLoading, base64ToBlob, stringToBase64) ---

        const showMessage = (message, type = 'info') => {
            const box = document.getElementById('messageBox');
            const colorClass = type === 'error' ? 'bg-red-500 text-white' :
                                 type === 'success' ? 'bg-green-500 text-white' :
                                 'bg-blue-500 text-white';

            if (type === 'error') {
                console.error("UI Error Message:", message);
            }

            box.className = `fixed top-20 left-1/2 transform -translate-x-1/2 w-full max-w-sm p-4 rounded-xl text-center z-50 transition-opacity duration-300 vault-card opacity-0 ${colorClass}`;
            box.textContent = message;

            box.classList.remove('hidden');
            setTimeout(() => { box.classList.remove('opacity-0'); box.classList.add('opacity-100'); }, 10);
            setTimeout(() => { box.classList.remove('opacity-100'); box.classList.add('opacity-0'); }, 3000);
            setTimeout(() => { box.classList.add('hidden'); }, 3500);
        };

        const toggleLoading = (buttonId, spinnerId, textId, isLoading) => {
            const button = document.getElementById(buttonId);
            const spinner = document.getElementById(spinnerId);
            const text = document.getElementById(textId);

            button.disabled = isLoading;
            if (isLoading) {
                spinner.classList.remove('hidden');
                text.classList.add('hidden');
                button.classList.add('opacity-75');
            } else {
                spinner.classList.add('hidden');
                text.classList.remove('hidden');
                button.classList.remove('opacity-75');
            }
        };
        
        const base64ToBlob = (base64Data, fileType) => {
            const byteCharacters = atob(base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: fileType });
        };

        const stringToBase64 = (str) => {
            const binaryString = String.fromCharCode.apply(null, new Uint8Array(new TextEncoder().encode(str)));
            return btoa(binaryString);
        };

        // --- Navigation and Routing ---

        /**
         * Navigates using the new clean URL query parameters.
         * Uses '|' as a path separator in the URL query parameter to avoid '%2F' encoding.
         * * @param {string} route - Either a folder path (e.g., '/your/folder/path/') or a file ID prefix (e.g., 'file/myFileId').
         * @param {boolean} replace - Use replaceState instead of pushState.
         */
        const navigate = (route, replace = false) => {
            let newUrl = '';

            if (route === '/') {
                // 1. User wants to go to the clean root path (e.g., just /)
                // This clears all search parameters from the URL.
                newUrl = window.location.pathname; 
            } else if (route.startsWith('file/')) {
                // 2. User wants to view a file
                const fileId = route.substring(5);
                const params = new URLSearchParams({ view: 'file', id: fileId });
                newUrl = '?' + params.toString();
            } else {
                // 3. User wants to navigate to a subfolder
                let path = route;
                
                // Normalize path (guarantee leading and trailing slash)
                path = '/' + path.split('/').filter(s => s).join('/') + '/';
                
                // Prepare path for URL parameter: replace internal slashes with pipes
                let pathParam = path.substring(1, path.length - 1).replace(/\//g, '|');
                
                const params = new URLSearchParams({ view: 'folder', nav: pathParam });
                newUrl = '?' + params.toString();
            }

            if (replace) {
                window.history.replaceState(null, '', newUrl);
            } else {
                window.history.pushState(null, '', newUrl);
            }
            handleRoute();
        };
        window.navigate = navigate;

        /**
         * Parses the URL query parameters, translating '|' back to '/' for internal use.
         * If no query parameters are present, it defaults to the root folder.
         */
        const getRouteParams = () => {
            const params = new URLSearchParams(window.location.search);
            const view = params.get('view'); 

            if (view === 'file') {
                const fileId = params.get('id');
                if (fileId) {
                    return { name: 'fileViewer', fileId: fileId };
                }
            }
            
            // Default to 'fileManager' (folder view)
            let pathParam = params.get('nav'); 
            let path = '/';

            if (pathParam && pathParam.length > 0) {
                // 1. Replace '|' back with '/'
                path = pathParam.replace(/\|/g, '/'); 
                // 2. Normalize path to internal representation (guarantee leading and trailing slash)
                path = '/' + path.split('/').filter(s => s).join('/') + '/';
            }
            
            return { name: 'fileManager', path: path };
        };

        const handleRoute = () => {
            if (!currentUserId) return; // Wait for auth

            const route = getRouteParams();
            const managerView = document.getElementById('fileManagerView');
            const viewerView = document.getElementById('fileViewerView');

            if (route.name === 'fileManager') {
                managerView.classList.remove('hidden');
                viewerView.classList.add('hidden');
                currentPath = route.path; 
                document.getElementById('currentPathDisplay').textContent = currentPath;
                renderBreadcrumbs();
                fetchFiles();
            } else if (route.name === 'fileViewer' && route.fileId) {
                managerView.classList.add('hidden');
                viewerView.classList.remove('hidden');
                renderFileViewer(route.fileId);
            }
        };
        window.addEventListener('popstate', handleRoute);

        const renderBreadcrumbs = () => {
            const breadcrumbsEl = document.getElementById('breadcrumbs');
            breadcrumbsEl.innerHTML = '';
            
            // Normalize currentPath for segment splitting
            const pathSegments = currentPath.split('/').filter(s => s); 

            // Root Link
            const rootLink = document.createElement('a');
            rootLink.className = 'text-indigo-600 hover:text-indigo-800 cursor-pointer';
            rootLink.textContent = 'Vault';
            // Use the clean navigate call for the root link
            rootLink.onclick = () => navigate('/'); 
            breadcrumbsEl.appendChild(rootLink);
            
            let cumulativePath = '/';

            pathSegments.forEach((segment, index) => {
                breadcrumbsEl.appendChild(document.createTextNode(' / '));

                // Calculate cumulative path for navigation
                cumulativePath = (cumulativePath === '/') ? `/${segment}/` : `${cumulativePath}${segment}/`;

                if (index < pathSegments.length - 1) {
                    // Intermediate folder
                    const segmentLink = document.createElement('a');
                    segmentLink.className = 'text-indigo-600 hover:text-indigo-800 cursor-pointer';
                    segmentLink.textContent = segment;
                    const pathCopy = cumulativePath;
                    segmentLink.onclick = () => navigate(pathCopy);
                    breadcrumbsEl.appendChild(segmentLink);
                } else {
                    // Current folder (just display text)
                    const currentSpan = document.createElement('span');
                    currentSpan.className = 'font-semibold text-gray-800';
                    currentSpan.textContent = segment;
                    breadcrumbsEl.appendChild(currentSpan);
                }
            });
        };
        
        // --- Authentication Logic (remains unchanged) ---
        
        document.getElementById('toggleAuthMode').addEventListener('click', () => {
            isSignUpMode = !isSignUpMode;
            document.getElementById('authText').textContent = isSignUpMode ? 'Sign Up' : 'Sign In';
            document.getElementById('toggleAuthMode').textContent = isSignUpMode ? 'Already have an account? Sign In' : 'Need an account? Sign Up';
        });

        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const buttonId = 'authSubmitButton';
            const spinnerId = 'authSpinner';
            const textId = 'authText';
            toggleLoading(buttonId, spinnerId, textId, true);
            try {
                if (isSignUpMode) {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showMessage('Account created successfully!', 'success');
                } else {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage('Signed in successfully!', 'success');
                }
            } catch (error) {
                console.error("Auth Error:", error);
                showMessage(error.message.replace('Firebase: ', ''), 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
            }
        });

        const signInWithGoogle = async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Auth Error:", error);
                showMessage(error.message.replace('Firebase: ', ''), 'error');
            }
        };
        window.signInWithGoogle = signInWithGoogle;

        const handleSignOut = async () => {
            try {
                await signOut(auth);
                showMessage('Signed out.', 'info');
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessage('Could not sign out.', 'error');
            }
        };
        window.handleSignOut = handleSignOut;
        // --- END Authentication Logic ---


        // --- Firestore Paths ---

        const getFileMetadataCollection = (userId) => {
            // Note: In your actual deployed environment, this path should use __app_id 
            return collection(db, `users/${userId}/files`);
        };

        const getFileChunksCollection = (userId, fileId) => {
            return collection(db, `users/${userId}/files/${fileId}/chunks`);
        };

        // --- File I/O Logic (Chunking & Dechunking) ---

        const fileToBase64 = (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                // Ensure we only extract the Base64 portion after the comma
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
                reader.readAsDataURL(file);
            });
        };

        /**
         * Saves Base64 data in chunks to Firestore, updating existing file or creating new metadata.
         */
        const saveFileChunks = async (base64Data, fileName, fileType, currentPath, fileId = null, onProgress = () => {}) => {
            if (!currentUserId) throw new Error("User not authenticated.");

            const chunks = [];
            for (let i = 0; i < base64Data.length; i += CHUNK_SIZE_CHARS) {
                chunks.push(base64Data.substring(i, i + CHUNK_SIZE_CHARS));
            }
            const totalChunks = chunks.length;
            const fileSize = base64Data.length;
            const metadataCollection = getFileMetadataCollection(currentUserId);

            // 1. Determine or Create Metadata Document
            const metadataRef = fileId ? doc(metadataCollection, fileId) : doc(metadataCollection);
            const isNewFile = !fileId;
            
            await setDoc(metadataRef, {
                fileName,
                fileType,
                fileSize,
                totalChunks,
                path: currentPath, 
                // Only update uploadedAt if it's a new file
                uploadedAt: isNewFile ? serverTimestamp() : (await getDoc(metadataRef)).data().uploadedAt,
                updatedAt: serverTimestamp(),
            }, { merge: true });

            // 2. Clear old chunks (if updating) and Save new Chunks
            const chunksCollection = getFileChunksCollection(currentUserId, metadataRef.id);
            
            if (fileId) {
                // For updates, aggressively delete existing chunks first
                const oldChunks = await getDocs(query(chunksCollection));
                for (const oldDoc of oldChunks.docs) {
                    await deleteDoc(oldDoc.ref);
                }
            }

            for (let i = 0; i < totalChunks; i++) {
                const chunkData = chunks[i];
                await setDoc(doc(chunksCollection, String(i)), {
                    chunkIndex: i,
                    data: chunkData
                });
                onProgress(((i + 1) / totalChunks) * 100);
            }

            return metadataRef.id;
        };
        
        /**
         * Loads and reconstructs a file from Firestore chunks, returning the full Base64 string.
         */
        const loadFileChunksBase64 = async (fileId, totalChunks) => {
            if (!currentUserId) throw new Error("User not authenticated.");

            const chunksCollection = getFileChunksCollection(currentUserId, fileId);
            const q = query(chunksCollection);
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                throw new Error("No chunks found for this file.");
            }

            const sortedChunks = querySnapshot.docs.map(docSnapshot => docSnapshot.data())
                .sort((a, b) => a.chunkIndex - b.chunkIndex);

            if (sortedChunks.length < totalChunks) {
                 console.warn(`File ${fileId} expected ${totalChunks} chunks, found ${sortedChunks.length}. Attempting reconstruction.`);
            }

            const allChunks = sortedChunks.map(chunk => chunk.data).join('');
            return allChunks;
        };


        // --- UI Interactions ---

        const isEditable = (fileType) => {
            const type = fileType.toLowerCase();
            return type.startsWith('text/') || 
                   type.includes('json') || 
                   type.includes('xml') ||
                   type.includes('javascript') ||
                   type.includes('css') ||
                   type.includes('html') ||
                   type.includes('svg') || 
                   type.includes('markdown'); 
        };

        document.getElementById('fileInput').addEventListener('change', (e) => {
            const uploadButton = document.getElementById('uploadButton');
            uploadButton.disabled = e.target.files.length === 0;
        });

        const showCreateFolderModal = () => {
            document.getElementById('folderModal').classList.remove('hidden');
            document.getElementById('folderNameInput').focus();
        };
        window.showCreateFolderModal = showCreateFolderModal;

        const hideCreateFolderModal = () => {
            document.getElementById('folderModal').classList.add('hidden');
            document.getElementById('folderNameInput').value = '';
        };
        window.hideCreateFolderModal = hideCreateFolderModal;
        
        // Modal for renaming logic
        let folderToRename = { id: null, name: null };

        const showRenameModal = (id, name) => {
            folderToRename = { id, name };
            document.getElementById('newFolderNameInput').value = name;
            document.getElementById('renameModal').classList.remove('hidden');
            document.getElementById('newFolderNameInput').focus();
            
            // Re-attach handler to ensure it uses the latest folderToRename context
            document.getElementById('renameExecuteButton').onclick = () => handleFolderRename(id, name);
        };
        window.showRenameModal = showRenameModal;

        const hideRenameModal = () => {
            document.getElementById('renameModal').classList.add('hidden');
            document.getElementById('newFolderNameInput').value = '';
            folderToRename = { id: null, name: null };
        };
        window.hideRenameModal = hideRenameModal;


        const createFolder = async () => {
            const folderName = document.getElementById('folderNameInput').value.trim();
            hideCreateFolderModal();

            if (!folderName) {
                showMessage('Folder name cannot be empty.', 'error');
                return;
            }

            const cleanName = folderName.replace(/[/\\]/g, '').trim();
            
            const metadataCollection = getFileMetadataCollection(currentUserId);
            
            try {
                // Check for existing placeholder or synthetic folder (for better UX)
                const existingDocs = await getDocs(query(metadataCollection, 
                    where('path', '==', currentPath), 
                    where('fileName', '==', cleanName)
                ));

                if (!existingDocs.empty) {
                     showMessage(`Folder or file with name '${cleanName}' already exists in this path.`, 'info');
                     navigate(currentPath + cleanName + '/');
                     return;
                }
                
                // Add a placeholder document that signifies the folder's existence.
                 await setDoc(doc(metadataCollection), {
                    fileName: cleanName,
                    fileType: 'folder/placeholder',
                    fileSize: 0,
                    totalChunks: 0,
                    path: currentPath,
                    isFolder: true,
                    uploadedAt: serverTimestamp(),
                });
                showMessage(`Folder '${cleanName}' created!`, 'success');
                // Navigate into the new folder for immediate use
                navigate(currentPath + cleanName + '/'); 
            } catch (error) {
                showMessage(`Failed to create folder: ${error.message}`, 'error');
            }
        };
        window.createFolder = createFolder;

        const handleFolderDelete = async (fileId, folderName) => {
            if (!window.confirm(`Are you sure you want to delete the folder '${folderName}'? This will recursively delete ALL files and subfolders inside it. This action is permanent.`)) {
                return;
            }
            
            const folderPathToDelete = currentPath + folderName + '/';

            try {
                const batch = writeBatch(db);
                const metadataCollection = getFileMetadataCollection(currentUserId);
                
                // 1. Query all documents contained in this folder path (recursively)
                const folderContentsQuery = query(metadataCollection, 
                    where('path', '>=', folderPathToDelete),
                    where('path', '<=', folderPathToDelete + '\uf8ff') // \uf8ff is a high-value Unicode character for range queries
                );
                
                const docsToDelete = await getDocs(folderContentsQuery);
                
                if (docsToDelete.empty) {
                    showMessage(`Folder '${folderName}' was already empty.`, 'info');
                }
                
                // 2. Add all contained files' metadata to the batch
                docsToDelete.docs.forEach(docSnapshot => {
                    const id = docSnapshot.id;
                    // Delete metadata doc. (Chunks must be handled by Firestore security rules or client iteration)
                    batch.delete(doc(metadataCollection, id)); 
                });
                
                // 3. Delete the folder's placeholder document (if it exists)
                if (fileId) {
                    batch.delete(doc(metadataCollection, fileId));
                }

                // 4. Commit the batch
                await batch.commit();

                showMessage(`Folder '${folderName}' and all ${docsToDelete.size} contained items deleted successfully!`, 'success');
                
                // 5. Navigate back to the parent folder
                if (currentPath !== '/') {
                    // Extract parent path: split by '/', filter empty strings, join back, add trailing '/'
                    const segments = currentPath.split('/').filter(s => s);
                    segments.pop(); // Remove current folder name
                    const parentPath = segments.length === 0 ? '/' : '/' + segments.join('/') + '/';
                    navigate(parentPath);
                } else {
                    fetchFiles();
                }

            } catch (error) {
                console.error("Folder Delete Error:", error);
                showMessage(`Failed to delete folder: ${error.message}`, 'error');
            }
        };
        window.handleFolderDelete = handleFolderDelete;
        
        const handleFolderRename = async (fileId, oldName) => {
            const newName = document.getElementById('newFolderNameInput').value.trim();
            hideRenameModal();

            if (!newName) {
                showMessage('New folder name cannot be empty.', 'error');
                return;
            }
            const cleanNewName = newName.replace(/[/\\]/g, '').trim();
            
            if (oldName === cleanNewName) {
                showMessage('Name is unchanged.', 'info');
                return;
            }
            
            // Old and new full path segments (must include currentPath)
            const oldPathSegment = `${currentPath}${oldName}/`;
            const newPathSegment = `${currentPath}${cleanNewName}/`;
            
            try {
                const batch = writeBatch(db);
                const metadataCollection = getFileMetadataCollection(currentUserId);
                
                // 1. Query all documents contained in this folder path (recursively)
                const folderContentsQuery = query(metadataCollection, 
                    where('path', '>=', oldPathSegment),
                    where('path', '<=', oldPathSegment + '\uf8ff')
                );
                
                const docsToRename = await getDocs(folderContentsQuery);

                if (docsToRename.empty && !fileId) {
                    throw new Error("Folder placeholder not found and folder is empty. Cannot rename.");
                }
                
                // 2. Update path for all contained documents
                docsToRename.docs.forEach(docSnapshot => {
                    const docData = docSnapshot.data();
                    // Replace the old path segment with the new one
                    const newPath = docData.path.replace(oldPathSegment, newPathSegment);
                    
                    batch.update(docSnapshot.ref, {
                        path: newPath,
                        updatedAt: serverTimestamp()
                    });
                });
                
                // 3. Update the folder's placeholder document (if it exists)
                if (fileId) {
                    batch.update(doc(metadataCollection, fileId), {
                        fileName: cleanNewName,
                        path: currentPath, // Placeholder stays in the current path
                        updatedAt: serverTimestamp()
                    });
                }
                
                // 4. Commit the batch
                await batch.commit();

                showMessage(`Folder renamed to '${cleanNewName}' successfully!`, 'success');
                
                // 5. Navigate to the new folder path
                navigate(newPathSegment);

            } catch (error) {
                console.error("Folder Rename Error:", error);
                showMessage(`Failed to rename folder: ${error.message}`, 'error');
            }
        };

        const handleFileUpload = async () => {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                showMessage('Please select a file first.', 'error');
                return;
            }

            const buttonId = 'uploadButton';
            const spinnerId = 'uploadSpinner';
            const textId = 'uploadText';
            const progressBarEl = document.getElementById('progressBar');
            const progressContainer = document.getElementById('uploadProgress');

            toggleLoading(buttonId, spinnerId, textId, true);
            progressBarEl.style.width = '0%';
            progressContainer.classList.remove('hidden');

            try {
                const base64Data = await fileToBase64(file);

                await saveFileChunks(
                    base64Data,
                    file.name,
                    file.type || 'application/octet-stream',
                    currentPath, // Pass the current folder path
                    null, // fileId is null for new upload
                    (progress) => {
                        progressBarEl.style.width = `${progress}%`;
                    }
                );

                showMessage('File uploaded and chunked successfully!', 'success');
                fileInput.value = null;
                uploadButton.disabled = true;
                fetchFiles();

            } catch (error) {
                console.error("Upload Error:", error);
                showMessage(`Upload failed: ${error.message}`, 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
                setTimeout(() => progressContainer.classList.add('hidden'), 500);
            }
        };
        window.handleFileUpload = handleFileUpload;

        /**
         * Renders the list of files and folders in the UI.
         */
        const renderFiles = (files) => {
            const fileListEl = document.getElementById('fileList');
            fileListEl.innerHTML = '';
            
            // Separate files and folders for sorting and display
            const filesToDisplay = files.filter(f => !f.isFolder);
            const folderFiles = files.filter(f => f.isFolder);

            // 1. Identify and normalize folders
            const folders = new Map();
            
            // Add explicit placeholder folders
            folderFiles.forEach(file => {
                 if (file.path === currentPath) {
                    // Store the metadata for the placeholder
                    folders.set(file.fileName, { name: file.fileName, id: file.id }); 
                 }
            });

            // Add synthetic folders (derived from file paths)
            filesToDisplay.forEach(file => {
                 // Check if the file is in an immediate subfolder
                if (file.path.startsWith(currentPath) && file.path.length > currentPath.length) {
                    const remainingPath = file.path.substring(currentPath.length);
                    const segments = remainingPath.split('/').filter(s => s); 
                    
                    if (segments.length >= 1) {
                        const folderName = segments[0];
                        if (!folders.has(folderName)) {
                             // Only add if no placeholder exists yet, and use a null ID
                             folders.set(folderName, { name: folderName, id: null });
                        }
                    }
                }
            });
            
            const folderEntries = Array.from(folders.values()).sort((a, b) => a.name.localeCompare(b.name));

            if (filesToDisplay.length === 0 && folderEntries.length === 0) {
                const placeholderLi = document.createElement('li');
                placeholderLi.className = 'p-4 text-gray-500 text-center';
                placeholderLi.textContent = 'This folder is empty.';
                fileListEl.appendChild(placeholderLi);
                return;
            }

            // 2. Render Folders
            folderEntries.forEach(folder => {
                const folderPath = currentPath + folder.name + '/';
                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center hover:bg-gray-50 transition rounded-lg cursor-pointer';
                li.onclick = () => navigate(folderPath);
                li.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <svg class="w-6 h-6 text-yellow-500" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v2a2 2 0 00-2-2h-8l-2-2H4a2 2 0 00-2 2v6a2 2 0 002 2h12a2 2 0 002-2v-2a2 2 0 01-2 2H4a2 2 0 01-2-2V6z"></path></svg>
                        <p class="font-semibold text-gray-800">${folder.name}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                         <p class="text-sm text-gray-500">Folder</p>
                         <div class="flex space-x-2">
                             <button title="Rename Folder" onclick="event.stopPropagation(); showRenameModal('${folder.id || ''}', '${folder.name}');" class="text-indigo-600 hover:text-indigo-800 p-1 rounded-full hover:bg-indigo-100 transition">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                            </button>
                            <button title="Delete Folder" onclick="event.stopPropagation(); handleFolderDelete('${folder.id || ''}', '${folder.name}');" class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                         </div>
                    </div>
                `;
                fileListEl.appendChild(li);
            });


            // 3. Render Files 
            const filesDirectlyInPath = filesToDisplay.filter(file => file.path === currentPath);
            
            filesDirectlyInPath.sort((a, b) => {
                const timeA = a.uploadedAt?.toDate?.()?.getTime() || 0;
                const timeB = b.uploadedAt?.toDate?.()?.getTime() || 0;
                return timeB - timeA; // Newest first
            });
            
            filesDirectlyInPath.forEach(file => {
                const fileSize = file.fileSize || 0;
                const fileSizeMB = (fileSize / 1024 / 1024).toFixed(2);
                const fileType = file.fileType || '';
                const fileName = file.fileName || 'Untitled File';

                let iconHtml = '';
                if (file.firstChunk) {
                    // Image with Base64 thumbnail for preview
                    iconHtml = `
                        <img src="data:${fileType};base64,${file.firstChunk}" 
                            class="file-preview-thumbnail object-cover" 
                            alt="Preview" 
                            onerror="this.src='https://placehold.co/48x48/CCCCCC/FFFFFF?text=IMG'">
                    `;
                } else if (fileType.startsWith('video/')) {
                    iconHtml = `<svg class="w-6 h-6 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14m-5-4v4"></path></svg>`;
                } else if (fileType.includes('pdf')) {
                     iconHtml = `<svg class="w-6 h-6 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>`;
                } else {
                    iconHtml = `<svg class="w-6 h-6 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"></path></svg>`;
                }

                const li = document.createElement('li');
                li.className = 'p-4 flex justify-between items-center hover:bg-gray-50 transition rounded-lg cursor-pointer';
                li.onclick = () => navigate(`file/${file.id}`); // View file on click
                li.innerHTML = `
                    <div class="flex items-center space-x-3 w-3/5">
                        <div class="flex-shrink-0">
                            ${iconHtml}
                        </div>
                        <p class="font-medium text-gray-800 truncate">${fileName}</p>
                    </div>
                    <div class="flex items-center space-x-4">
                        <p class="text-sm text-gray-500 hidden sm:block">${fileSizeMB} MB</p>
                        <button class="delete-btn bg-red-500 text-white p-2 rounded-full hover:bg-red-600 transition flex-shrink-0" data-file-id="${file.id}" title="Delete File" onclick="event.stopPropagation(); handleFileDelete('${file.id}');">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </div>
                `;
                fileListEl.appendChild(li);
            });
        };

        const renderFileViewer = async (fileId) => {
            const viewerTitleEl = document.getElementById('viewerTitle');
            const viewerMetadataEl = document.getElementById('viewerMetadata');
            const viewerContentEl = document.getElementById('viewerContent');
            const viewerLoadingEl = document.getElementById('viewerLoading');
            const editorActionsEl = document.getElementById('editorActions');
            const backButtonEl = document.getElementById('backToFolderButton');

            viewerContentEl.innerHTML = '';
            editorActionsEl.classList.add('hidden');
            viewerTitleEl.textContent = 'Loading File...';
            viewerMetadataEl.textContent = '';
            viewerLoadingEl.classList.remove('hidden');

            try {
                // 1. Fetch metadata
                const metadataDoc = await getDoc(doc(getFileMetadataCollection(currentUserId), fileId));
                if (!metadataDoc.exists()) {
                    throw new Error("File not found.");
                }
                const file = { id: metadataDoc.id, ...metadataDoc.data() };
                const totalChunks = file.totalChunks || 0;
                const fileName = file.fileName || 'Unknown File';
                const fileSizeMB = ((file.fileSize || 0) / 1024 / 1024).toFixed(2);
                const fileType = file.fileType || 'application/octet-stream';
                
                viewerTitleEl.textContent = fileName;
                viewerMetadataEl.textContent = `Type: ${fileType} | Size: ${fileSizeMB} MB | Chunks: ${totalChunks}`;
                
                // Update the back button to navigate to the file's containing folder path.
                const containingFolderPath = file.path; // Already ends with '/'
                backButtonEl.onclick = () => navigate(containingFolderPath);
                
                // 2. Load all chunks
                const fullBase64 = await loadFileChunksBase64(fileId, totalChunks);
                const blob = base64ToBlob(fullBase64, fileType);
                const objectUrl = URL.createObjectURL(blob);

                // 3. Render content based on MIME type
                if (fileType.startsWith('image/')) {
                    viewerContentEl.innerHTML = `<img src="${objectUrl}" alt="${fileName}" class="max-w-full max-h-full rounded-lg shadow-xl" onerror="this.outerHTML='<p class=\\'text-red-500\\'>Error displaying image.</p>'">`;
                } else if (fileType.startsWith('video/')) {
                    viewerContentEl.innerHTML = `<video src="${objectUrl}" controls class="max-w-full max-h-full rounded-lg shadow-xl"></video>`;
                } else if (isEditable(fileType)) {
                    // For editable text-based files, render an editor
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const content = e.target.result;
                        // Determine if we should apply syntax highlighting (basic guess)
                        const editorClass = fileType.includes('html') || fileType.includes('css') || fileType.includes('javascript') || fileType.includes('json') || fileType.includes('xml') ? 'language-code' : '';
                        
                        viewerContentEl.innerHTML = `
                            <textarea id="fileEditor" class="w-full h-[60vh] p-4 text-sm bg-gray-50 border border-gray-200 rounded-lg resize-none font-mono ${editorClass}">${content}</textarea>
                        `;
                        editorActionsEl.classList.remove('hidden');
                        
                        // Attach save listener
                        document.getElementById('saveButton').onclick = () => saveFileContent(fileId, fileName, fileType);
                    };
                    reader.readAsText(blob);
                } else {
                    // Fallback: offer download button
                    viewerContentEl.innerHTML = `
                        <div class="text-center p-8">
                            <p class="text-lg text-gray-700 mb-4">No in-browser preview available for ${fileType}.</p>
                            <button onclick="downloadBlob('${objectUrl}', '${fileName}')" class="bg-indigo-600 text-white py-2 px-4 rounded-lg font-semibold hover:bg-indigo-700 transition">
                                Download File
                            </button>
                        </div>
                    `;
                }
                
                // Cleanup Object URL after rendering (it's safe here because content is loaded)
                URL.revokeObjectURL(objectUrl); 

            } catch (error) {
                console.error("Viewer Error:", error);
                viewerContentEl.innerHTML = `<p class="text-red-500">Failed to load file: ${error.message}</p>`;
                showMessage(`Failed to load file: ${error.message}`, 'error');
            } finally {
                viewerLoadingEl.classList.add('hidden');
            }
        };
        window.renderFileViewer = renderFileViewer; 

        const saveFileContent = async (fileId, fileName, fileType) => {
            const editorEl = document.getElementById('fileEditor');
            const newContent = editorEl.value;
            const newBase64Data = stringToBase64(newContent);
            
            const buttonId = 'saveButton';
            const spinnerId = 'saveSpinner';
            const textId = 'saveText';

            toggleLoading(buttonId, spinnerId, textId, true);

            try {
                // Get the current path from the file's metadata for re-saving
                const metadataDoc = await getDoc(doc(getFileMetadataCollection(currentUserId), fileId));
                const currentFilePath = metadataDoc.data().path || '/';

                await saveFileChunks(
                    newBase64Data, 
                    fileName, 
                    fileType, 
                    currentFilePath, 
                    fileId // Pass fileId to update existing document
                );
                
                showMessage(`File '${fileName}' saved successfully!`, 'success');
                // Re-render the viewer to show updated metadata (size, chunks, etc.)
                renderFileViewer(fileId); 

            } catch (error) {
                console.error("Save Error:", error);
                showMessage(`Failed to save file: ${error.message}`, 'error');
            } finally {
                toggleLoading(buttonId, spinnerId, textId, false);
            }
        };

        const downloadBlob = (objectUrl, fileName) => {
            const a = document.createElement('a');
            a.href = objectUrl;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
        window.downloadBlob = downloadBlob;

        const handleFileDelete = async (fileId) => {
            if (!window.confirm("Are you sure you want to delete this file and all its chunks? This action is permanent.")) {
                return;
            }

            try {
                // 1. Delete all chunks
                const chunksCollection = getFileChunksCollection(currentUserId, fileId);
                const q = query(chunksCollection);
                const chunkDocs = await getDocs(q);

                for (const docSnapshot of chunkDocs.docs) {
                    await deleteDoc(docSnapshot.ref);
                }

                // 2. Delete the metadata document
                const metadataRef = doc(getFileMetadataCollection(currentUserId), fileId);
                await deleteDoc(metadataRef);

                showMessage('File and all chunks deleted successfully!', 'success');
                
                // If we deleted the file we are currently viewing, navigate home.
                const route = getRouteParams();
                if (route.name === 'fileViewer' && route.fileId === fileId) {
                    navigate(currentPath);
                } else {
                    fetchFiles();
                }

            } catch (error) {
                console.error("Delete Error:", error);
                showMessage(`Failed to delete file: ${error.message}`, 'error');
            }
        };
        window.handleFileDelete = handleFileDelete;

        const fetchFiles = async () => {
            if (!currentUserId) return;

            const fileListEl = document.getElementById('fileList');
            fileListEl.innerHTML = '<li class="p-4 text-center text-indigo-600"><div class="mx-auto spinner"></div><p class="mt-2">Loading files...</p></li>';

            try {
                const metadataCollection = getFileMetadataCollection(currentUserId);
                const q = query(metadataCollection);
                const querySnapshot = await getDocs(q);

                const previewPromises = [];

                const allFiles = querySnapshot.docs.map(docSnapshot => { 
                    const data = docSnapshot.data();
                    const fileId = docSnapshot.id;

                    // Ensure path exists and is normalized
                    data.path = (data.path === undefined || data.path === null || data.path === '') ? '/' : data.path;
                    if (data.path !== '/' && !data.path.endsWith('/')) {
                        data.path += '/';
                    }
                    
                    const file = { id: fileId, ...data };

                    // FIX: Load first chunk asynchronously and wait via Promise.all
                    if (file.fileType && file.fileType.startsWith('image/') && file.totalChunks > 0) {
                        const chunkPromise = getDoc(doc(getFileChunksCollection(currentUserId, file.id), '0'))
                            .then(chunkDoc => {
                                if (chunkDoc.exists()) {
                                    file.firstChunk = chunkDoc.data().data;
                                }
                            })
                            .catch(e => console.warn(`Failed to fetch first chunk for ${file.fileName}:`, e));
                        
                        previewPromises.push(chunkPromise);
                    }
                    return file;
                });

                // Wait for all image previews to load before continuing
                await Promise.all(previewPromises);

                // --- Client-side Filtering ---
                const filesInCurrentPath = allFiles.filter(file => {
                    // Check if file is directly in the current path (file or placeholder folder)
                    if (file.path === currentPath) {
                        return true;
                    }

                    // Check for immediate subfolders (synthetic folders)
                    if (file.path.startsWith(currentPath) && file.path.length > currentPath.length) {
                        const remainingPath = file.path.substring(currentPath.length);
                        // Check if the remainder path (excluding the trailing slash) contains no more slashes
                        const segments = remainingPath.split('/').filter(s => s); 
                        if (segments.length === 1) { // Only one segment means it's an immediate subfolder
                            return true; 
                        }
                    }
                    
                    return false;
                });
                
                renderFiles(filesInCurrentPath);

            } catch (error) {
                console.error("Fetch Files Error:", error);
                showMessage(`Could not load files. Error: ${error.message || 'Unknown error'}. Please check console.`, 'error');
                fileListEl.innerHTML = '<li class="p-4 text-center text-red-500">Failed to load files.</li>';
            }
        };


        // --- Auth State Change Listener ---

        onAuthStateChanged(auth, (user) => {
            const authView = document.getElementById('authView');
            const signOutButton = document.getElementById('signOutButton');
            const fileManagerView = document.getElementById('fileManagerView');

            if (user) {
                currentUserId = user.uid;
                authView.classList.add('hidden');
                signOutButton.classList.remove('hidden');
                // Call handleRoute after successful sign-in
                handleRoute();
            } else {
                currentUserId = null;
                authView.classList.remove('hidden');
                // Hide file views on sign-out
                fileManagerView.classList.add('hidden');
                document.getElementById('fileViewerView').classList.add('hidden');
                signOutButton.classList.add('hidden');
            }
        });
        
        // Ensure initial route is handled on page load
        if (document.readyState === 'complete') {
            handleRoute();
        } else {
            window.addEventListener('load', handleRoute);
        }

    </script>
</body>
</html>

